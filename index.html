<!DOCTYPE html>
<html>
<head>
    <title>BumpyBall/Pucks Cheat Analyzer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 { color: #333; margin-bottom: 30px; }
        h2 { color: #555; margin: 20px 0; }
        
        .panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }
        
        input, button {
            padding: 12px 20px;
            margin: 5px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #5a67d8;
        }
        
        .detection-card {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-left: 4px solid #48bb78;
        }
        
        .detection-card.high { border-left-color: #f56565; }
        .detection-card.medium { border-left-color: #ed8936; }
        
        .replay-canvas {
            background: #1a202c;
            border-radius: 10px;
            width: 100%;
            height: 400px;
            position: relative;
            overflow: hidden;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-box {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .stat-box h3 { font-size: 14px; color: #666; margin-bottom: 10px; }
        .stat-box .number { font-size: 32px; font-weight: bold; color: #667eea; }
        
        .tab-container {
            margin: 20px 0;
        }
        
        .tab-buttons {
            display: flex;
            gap: 10px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }
        
        .tab-button {
            background: none;
            border: none;
            color: #666;
            font-size: 16px;
            cursor: pointer;
            padding: 10px 20px;
        }
        
        .tab-button.active {
            color: #667eea;
            border-bottom: 2px solid #667eea;
        }
        
        .tab-content {
            display: none;
            padding: 20px 0;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .server-item {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .server-item:hover {
            transform: translateX(5px);
            background: #f0f0f0;
        }
        
        .badge {
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .badge.online { background: #c6f6d5; color: #22543d; }
        .badge.cheater { background: #fed7d7; color: #742a2a; }
        
        @media (max-width: 768px) {
            .container { padding: 15px; }
            input, button { width: 100%; margin: 5px 0; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöó BumpyBall/Pucks Cheat Analyzer</h1>
        
        <!-- Connection Panel -->
        <div class="panel">
            <h2>üîå Connect to Game Server</h2>
            <input type="text" id="serverUrl" placeholder="wss://game-server-url.com" value="wss://www.pucks.io">
            <input type="text" id="serverPassword" placeholder="Server Password (optional)">
            <button onclick="connectToServer()">Connect & Monitor</button>
            <div id="connectionStatus" style="margin-top: 10px; color: #666;"></div>
        </div>
        
        <!-- Stats Overview -->
        <div class="stats-grid">
            <div class="stat-box">
                <h3>Matches Analyzed</h3>
                <div class="number" id="totalMatches">0</div>
            </div>
            <div class="stat-box">
                <h3>Suspicious Players</h3>
                <div class="number" id="suspiciousCount">0</div>
            </div>
            <div class="stat-box">
                <h3>Auto-Boost Detections</h3>
                <div class="number" id="boostDetections">0</div>
            </div>
            <div class="stat-box">
                <h3>Confidence Rate</h3>
                <div class="number" id="confidenceRate">0%</div>
            </div>
        </div>
        
        <!-- Tabs -->
        <div class="tab-container">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab('live')">Live Monitor</button>
                <button class="tab-button" onclick="switchTab('detections')">Detections</button>
                <button class="tab-button" onclick="switchTab('replays')">Replays</button>
                <button class="tab-button" onclick="switchTab('servers')">Servers</button>
            </div>
            
            <!-- Live Monitor Tab -->
            <div id="liveTab" class="tab-content active">
                <div class="replay-canvas">
                    <canvas id="liveCanvas" width="800" height="400"></canvas>
                </div>
                <div class="controls">
                    <button onclick="startRecording()">‚è∫ Start Recording</button>
                    <button onclick="stopRecording()">‚èπ Stop Recording</button>
                    <span id="recordingTimer">00:00</span>
                </div>
                
                <h3>Live Players</h3>
                <div id="livePlayers"></div>
            </div>
            
            <!-- Detections Tab -->
            <div id="detectionsTab" class="tab-content">
                <div class="controls">
                    <button onclick="exportDetections()">üì• Export CSV</button>
                    <button onclick="clearDetections()">üóë Clear All</button>
                </div>
                <div id="detectionsList"></div>
            </div>
            
            <!-- Replays Tab -->
            <div id="replaysTab" class="tab-content">
                <div id="replaysList"></div>
                <div class="replay-canvas" style="display: none;" id="replayViewer">
                    <canvas id="replayCanvas" width="800" height="400"></canvas>
                    <div class="controls">
                        <button onclick="playReplay()">‚ñ∂ Play</button>
                        <button onclick="pauseReplay()">‚è∏ Pause</button>
                        <input type="range" id="replayTimeline" min="0" max="100" value="0" style="width: 300px;">
                    </div>
                </div>
            </div>
            
            <!-- Servers Tab -->
            <div id="serversTab" class="tab-content">
                <div class="controls">
                    <button onclick="addServer()">‚ûï Add Server</button>
                </div>
                <div id="serversList"></div>
            </div>
        </div>
    </div>
    
    <script>
        // Configuration
        const PUSHER_KEY = 'your-pusher-key'; // Get from pusher.com (free tier)
        const PUSHER_CLUSTER = 'us2';
        
        // State
        let currentRecording = null;
        let livePlayers = new Map();
        let detections = JSON.parse(localStorage.getItem('detections') || '[]');
        let servers = JSON.parse(localStorage.getItem('servers') || '[]');
        let matchesAnalyzed = parseInt(localStorage.getItem('matchesAnalyzed') || '0');
        let wsConnection = null;
        let recordingInterval = null;
        let recordingStartTime = null;
        
        // Packet decoder (based on the cheat script)
        class PacketDecoder {
            static decode(uint8Array) {
                try {
                    // This would use the BR decoder from the cheat script
                    // For now, we'll simulate based on patterns
                    return JSON.parse(new TextDecoder().decode(uint8Array));
                } catch (e) {
                    return null;
                }
            }
            
            static detectAutoBoost(packets) {
                let boostTimings = [];
                let lastBoost = 0;
                let suspicious = 0;
                
                packets.forEach(p => {
                    if (p.type === 7) { // Movement packet
                        const currentTime = p.timestamp;
                        if (lastBoost > 0) {
                            const interval = currentTime - lastBoost;
                            // Auto-boost script uses exactly 130ms intervals
                            if (interval >= 125 && interval <= 135) {
                                suspicious++;
                            }
                        }
                        lastBoost = currentTime;
                        boostTimings.push(lastBoost);
                    }
                });
                
                return {
                    isCheating: suspicious > 10,
                    confidence: Math.min(100, (suspicious / boostTimings.length) * 100),
                    pattern: boostTimings
                };
            }
        }
        
        // Connect to game server
        async function connectToServer() {
            const url = document.getElementById('serverUrl').value;
            const password = document.getElementById('serverPassword').value;
            
            document.getElementById('connectionStatus').innerText = 'Connecting...';
            
            try {
                wsConnection = new WebSocket(url);
                
                wsConnection.onopen = () => {
                    document.getElementById('connectionStatus').innerHTML = '‚úÖ Connected to ' + url;
                    
                    // Send password if provided
                    if (password) {
                        // Format based on game protocol
                        wsConnection.send(JSON.stringify({
                            type: 'join',
                            password: password
                        }));
                    }
                    
                    startRecording();
                };
                
                wsConnection.onmessage = (event) => {
                    // Convert blob to array buffer
                    if (event.data instanceof Blob) {
                        event.data.arrayBuffer().then(buffer => {
                            const packet = new Uint8Array(buffer);
                            handlePacket(packet);
                        });
                    } else {
                        handlePacket(event.data);
                    }
                };
                
                wsConnection.onclose = () => {
                    document.getElementById('connectionStatus').innerHTML = '‚ùå Disconnected';
                    stopRecording();
                };
                
                wsConnection.onerror = (error) => {
                    document.getElementById('connectionStatus').innerHTML = '‚ö†Ô∏è Connection error';
                    console.error('WebSocket error:', error);
                };
                
            } catch (error) {
                document.getElementById('connectionStatus').innerHTML = '‚ùå Failed to connect: ' + error.message;
            }
        }
        
        // Handle incoming packets
        function handlePacket(data) {
            if (!currentRecording) return;
            
            const packet = {
                timestamp: Date.now() - recordingStartTime,
                data: data,
                type: detectPacketType(data)
            };
            
            currentRecording.packets.push(packet);
            
            // Update live view
            updateLiveView(packet);
            
            // Check for cheats every 100 packets
            if (currentRecording.packets.length % 100 === 0) {
                analyzeCurrentRecording();
            }
        }
        
        // Detect packet type (simplified from cheat script)
        function detectPacketType(data) {
            // This would parse the actual game packets
            // For now, return a simulated type
            return Math.floor(Math.random() * 10) + 1;
        }
        
        // Start recording
        function startRecording() {
            if (recordingInterval) clearInterval(recordingInterval);
            
            recordingStartTime = Date.now();
            currentRecording = {
                id: Date.now(),
                startTime: recordingStartTime,
                server: document.getElementById('serverUrl').value,
                packets: [],
                players: new Map()
            };
            
            recordingInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                const mins = Math.floor(elapsed / 60);
                const secs = elapsed % 60;
                document.getElementById('recordingTimer').innerText = 
                    `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }, 1000);
            
            console.log('Recording started');
        }
        
        // Stop recording and analyze
        function stopRecording() {
            if (recordingInterval) {
                clearInterval(recordingInterval);
                recordingInterval = null;
            }
            
            if (currentRecording) {
                // Final analysis
                analyzeCurrentRecording(true);
                
                // Save recording
                const recordings = JSON.parse(localStorage.getItem('recordings') || '[]');
                recordings.push({
                    id: currentRecording.id,
                    server: currentRecording.server,
                    duration: Date.now() - currentRecording.startTime,
                    packetCount: currentRecording.packets.length,
                    timestamp: new Date().toISOString()
                });
                localStorage.setItem('recordings', JSON.stringify(recordings));
                
                matchesAnalyzed++;
                localStorage.setItem('matchesAnalyzed', matchesAnalyzed.toString());
                updateStats();
                
                currentRecording = null;
                document.getElementById('recordingTimer').innerText = '00:00';
            }
        }
        
        // Analyze recording for cheats
        function analyzeCurrentRecording(final = false) {
            if (!currentRecording) return;
            
            const analysis = PacketDecoder.detectAutoBoost(currentRecording.packets);
            
            if (analysis.isCheating || final) {
                const detection = {
                    id: Date.now(),
                    timestamp: new Date().toISOString(),
                    server: currentRecording.server,
                    confidence: analysis.confidence,
                    pattern: analysis.pattern,
                    packets: final ? currentRecording.packets.slice(-50) : []
                };
                
                detections.push(detection);
                localStorage.setItem('detections', JSON.stringify(detections));
                
                if (analysis.isCheating) {
                    showNotification('üö® Cheater detected!', 'warning');
                }
                
                updateDetectionsList();
                updateStats();
            }
        }
        
        // Update live view
        function updateLiveView(packet) {
            const canvas = document.getElementById('liveCanvas');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.clearRect(0, 0, 800, 400);
            
            // Draw field
            ctx.fillStyle = '#2d3748';
            ctx.fillRect(0, 0, 800, 400);
            
            // Draw center line
            ctx.strokeStyle = '#718096';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(400, 0);
            ctx.lineTo(400, 400);
            ctx.stroke();
            
            // Draw center circle
            ctx.beginPath();
            ctx.arc(400, 200, 80, 0, Math.PI * 2);
            ctx.strokeStyle = '#718096';
            ctx.stroke();
            
            // Draw players (simplified)
            livePlayers.forEach((player, id) => {
                ctx.fillStyle = player.team === 0 ? '#fc8181' : '#63b3ed';
                ctx.beginPath();
                ctx.arc(player.x * 400 + 400, player.y * 200 + 200, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw name
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.fillText(player.name, player.x * 400 + 400 - 20, player.y * 200 + 200 - 15);
            });
            
            // Update players list
            const playersHtml = Array.from(livePlayers.values()).map(p => `
                <div class="server-item">
                    <span>${p.name} (Team ${p.team})</span>
                    <span class="badge ${p.suspicious ? 'cheater' : 'online'}">
                        ${p.suspicious ? '‚ö†Ô∏è Suspicious' : '‚úÖ Clean'}
                    </span>
                </div>
            `).join('');
            
            document.getElementById('livePlayers').innerHTML = playersHtml || '<p>No players yet</p>';
        }
        
        // Update detections list
        function updateDetectionsList() {
            const list = document.getElementById('detectionsList');
            list.innerHTML = detections.reverse().map(d => `
                <div class="detection-card ${d.confidence > 80 ? 'high' : 'medium'}">
                    <div style="display: flex; justify-content: space-between;">
                        <strong>‚ö†Ô∏è Cheater Detected</strong>
                        <span>${new Date(d.timestamp).toLocaleString()}</span>
                    </div>
                    <p>Server: ${d.server}</p>
                    <p>Confidence: ${d.confidence.toFixed(1)}%</p>
                    <p>Pattern: ${d.pattern.length} suspicious timings</p>
                    <button onclick="viewReplay('${d.id}')">View Evidence</button>
                </div>
            `).join('');
            
            document.getElementById('boostDetections').innerText = detections.length;
        }
        
        // Update stats
        function updateStats() {
            document.getElementById('totalMatches').innerText = matchesAnalyzed;
            document.getElementById('suspiciousCount').innerText = detections.length;
            
            const avgConfidence = detections.reduce((sum, d) => sum + d.confidence, 0) / (detections.length || 1);
            document.getElementById('confidenceRate').innerText = avgConfidence.toFixed(0) + '%';
        }
        
        // Switch tabs
        function switchTab(tab) {
            document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tab + 'Tab').classList.add('active');
        }
        
        // Export detections
        function exportDetections() {
            const csv = detections.map(d => 
                `${d.timestamp},${d.server},${d.confidence},${d.pattern.length}`
            ).join('\n');
            
            const blob = new Blob(['Timestamp,Server,Confidence,SuspiciousCount\n' + csv], {type: 'text/csv'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'detections.csv';
            a.click();
        }
        
        // Clear detections
        function clearDetections() {
            if (confirm('Clear all detections?')) {
                detections = [];
                localStorage.setItem('detections', '[]');
                updateDetectionsList();
                updateStats();
            }
        }
        
        // Add server
        function addServer() {
            const url = prompt('Enter server URL (e.g., wss://www.pucks.io):');
            if (url) {
                servers.push({
                    url: url,
                    added: new Date().toISOString()
                });
                localStorage.setItem('servers', JSON.stringify(servers));
                updateServersList();
            }
        }
        
        // Update servers list
        function updateServersList() {
            const list = document.getElementById('serversList');
            list.innerHTML = servers.map(s => `
                <div class="server-item" onclick="document.getElementById('serverUrl').value='${s.url}'">
                    <span>üîó ${s.url}</span>
                    <span class="badge online">Saved</span>
                </div>
            `).join('');
        }
        
        // Notification
        function showNotification(message, type) {
            if (Notification.permission === 'granted') {
                new Notification(message);
            } else if (Notification.permission !== 'denied') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        new Notification(message);
                    }
                });
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            updateDetectionsList();
            updateServersList();
            updateStats();
            
            // Request notification permission
            if ('Notification' in window) {
                Notification.requestPermission();
            }
            
            // Load last used server
            const lastServer = localStorage.getItem('lastServer');
            if (lastServer) {
                document.getElementById('serverUrl').value = lastServer;
            }
        });
    </script>
</body>
</html>
