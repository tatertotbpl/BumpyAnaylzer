<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DUCK ANALYZER - Live Tournament Monitor</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(145deg, #0d0d1a 0%, #1a1a2e 100%);
      color: #e0e0e0;
      min-height: 100vh;
    }
    
    .header {
      background: linear-gradient(90deg, rgba(0,212,255,0.15) 0%, rgba(255,68,102,0.15) 100%);
      padding: 20px 30px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .logo {
      font-size: 24px;
      font-weight: 600;
    }
    .logo .duck { color: #00d4ff; }
    .logo .mod { color: #888; font-weight: 300; margin-left: 8px; }
    
    .main-grid {
      display: grid;
      grid-template-columns: 350px 1fr;
      gap: 20px;
      padding: 20px 30px;
    }
    
    @media (max-width: 1000px) {
      .main-grid { grid-template-columns: 1fr; }
    }
    
    /* Server Panel */
    .server-panel {
      background: linear-gradient(145deg, #1a1a2e 0%, #0d0d1a 100%);
      border: 1px solid rgba(0,212,255,0.2);
      border-radius: 12px;
      overflow: hidden;
    }
    
    .panel-header {
      background: rgba(0,212,255,0.1);
      padding: 12px 16px;
      font-weight: 600;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 1px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .panel-content { padding: 16px; }
    
    .server-group {
      margin-bottom: 20px;
    }
    
    .group-title {
      color: #00d4ff;
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 10px;
      text-transform: uppercase;
    }
    
    .server-card {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(0,212,255,0.1);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .server-card:hover {
      background: rgba(0,212,255,0.1);
      border-color: #00d4ff;
    }
    .server-card.selected {
      background: rgba(0,212,255,0.15);
      border-color: #00d4ff;
      box-shadow: 0 0 15px rgba(0,212,255,0.3);
    }
    .server-card .name { font-weight: 600; }
    .server-card .status {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #4ade80;
      box-shadow: 0 0 10px #4ade80;
    }
    .server-card .status.offline { background: #ff4466; box-shadow: 0 0 10px #ff4466; }
    
    .password-input {
      width: 100%;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(0,212,255,0.3);
      border-radius: 6px;
      padding: 10px 12px;
      color: #fff;
      margin: 10px 0;
    }
    
    .connect-btn {
      width: 100%;
      background: linear-gradient(145deg, #00d4ff 0%, #00a0cc 100%);
      border: none;
      color: #000;
      padding: 12px;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      margin: 5px 0;
    }
    .connect-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .status-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 15px;
      padding: 10px;
      background: rgba(255,255,255,0.03);
      border-radius: 6px;
    }
    .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }
    .status-dot.connected { background: #4ade80; box-shadow: 0 0 10px #4ade80; }
    .status-dot.connecting { background: #fbbf24; box-shadow: 0 0 10px #fbbf24; }
    .status-dot.disconnected { background: #ff4466; box-shadow: 0 0 10px #ff4466; }
    
    /* Live View Panel */
    .live-panel {
      background: linear-gradient(145deg, #1a1a2e 0%, #0d0d1a 100%);
      border: 1px solid rgba(0,212,255,0.2);
      border-radius: 12px;
      overflow: hidden;
    }
    
    .field-container {
      position: relative;
      width: 100%;
      aspect-ratio: 45/65;
      max-width: 500px;
      margin: 0 auto;
      background: #0a0a12;
    }
    
    #liveCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    .stats-row {
      display: flex;
      justify-content: space-between;
      padding: 10px 16px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    
    .player-list {
      max-height: 200px;
      overflow-y: auto;
      padding: 10px 16px;
    }
    
    .player-item {
      display: flex;
      align-items: center;
      padding: 4px 0;
    }
    .player-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 8px;
    }
    .player-dot.blue { background: #00d4ff; box-shadow: 0 0 10px #00d4ff; }
    .player-dot.red { background: #ff4466; box-shadow: 0 0 10px #ff4466; }
    .player-name { flex: 1; }
    .player-position { color: #888; font-size: 11px; }
    
    .tabs {
      display: flex;
      gap: 2px;
      background: rgba(0,0,0,0.3);
      padding: 4px;
      border-radius: 8px;
      margin: 10px 16px;
    }
    .tab {
      flex: 1;
      padding: 8px;
      text-align: center;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
    }
    .tab.active {
      background: #00d4ff;
      color: #000;
    }
    
    .saved-games {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 10px;
      padding: 16px;
    }
    
    .game-card {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(0,212,255,0.1);
      border-radius: 8px;
      padding: 12px;
      cursor: pointer;
    }
    .game-card:hover { border-color: #00d4ff; }
    .game-date { font-size: 11px; color: #888; }
    .game-score {
      display: flex;
      justify-content: space-between;
      font-size: 18px;
      margin: 8px 0;
    }
    
    .btn {
      background: linear-gradient(145deg, #00d4ff 0%, #00a0cc 100%);
      border: none;
      color: #000;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
    }
    .btn.small { padding: 4px 8px; }
    
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div class="header">
    <div class="logo">
      <span class="duck">DUCK</span>
      <span class="mod">ANALYZER</span>
    </div>
    <div>
      <button class="btn small" id="showSavedBtn">üìÅ Saved Games</button>
      <button class="btn small" id="clearSavedBtn">üóë Clear</button>
    </div>
  </div>
  
  <div class="main-grid">
    <!-- LEFT PANEL - Server Selection -->
    <div class="server-panel">
      <div class="panel-header">
        <span>üîå TOURNAMENT SERVERS</span>
        <span id="connectionStatus" class="status-dot disconnected"></span>
      </div>
      <div class="panel-content">
        <div class="server-group">
          <div class="group-title">üá∫üá∏ NEW YORK</div>
          <div id="ny-servers"></div>
        </div>
        
        <div class="server-group">
          <div class="group-title">üá©üá™ FRANKFURT</div>
          <div id="fra-servers"></div>
        </div>
        
        <input type="password" id="passwordInput" class="password-input" placeholder="Server password" value="rodshot">
        
        <button class="connect-btn" id="connectBtn" disabled>üöÄ CONNECT TO SERVER</button>
        <button class="connect-btn" id="disconnectBtn" style="background: #ff4466; color: white;" disabled>üîå DISCONNECT</button>
        
        <div class="status-indicator">
          <span id="statusDot" class="status-dot disconnected"></span>
          <span id="statusText">Not connected</span>
        </div>
        
        <div style="margin-top: 15px;">
          <div class="tabs">
            <div class="tab active" data-tab="live">LIVE</div>
            <div class="tab" data-tab="players">PLAYERS</div>
            <div class="tab" data-tab="saved">SAVED</div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- RIGHT PANEL - Live View -->
    <div class="live-panel">
      <div class="panel-header">
        <span>üì∫ LIVE SPECTATOR</span>
        <span id="matchTime">0:00</span>
      </div>
      
      <!-- LIVE TAB -->
      <div id="liveTab" class="tab-pane">
        <div class="field-container">
          <canvas id="liveCanvas" width="450" height="650"></canvas>
        </div>
        
        <div class="stats-row">
          <span>Players: <span id="playerCount">0</span></span>
          <span>My ID: <span id="myId">-</span></span>
        </div>
        
        <div class="player-list" id="playerList"></div>
      </div>
      
      <!-- PLAYERS TAB -->
      <div id="playersTab" class="tab-pane hidden">
        <div style="padding: 16px;">
          <div style="margin-bottom: 10px;">
            <button class="btn small" id="manualSpectatorBtn">üëÅÔ∏è Go Spectator</button>
            <button class="btn small" id="startRecordBtn">‚è∫ Record</button>
          </div>
          <div id="detailedPlayerList"></div>
        </div>
      </div>
      
      <!-- SAVED TAB -->
      <div id="savedTab" class="tab-pane hidden">
        <div style="padding: 16px;">
          <div id="savedGamesList" class="saved-games"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ==================== CONSTANTS ====================
    const FIELD = {
      minX: -15, maxX: 30,
      minZ: -25, maxZ: 40,
      centerX: 7.5, centerZ: 7.5
    };
    
    const SERVERS = {
      ny: [
        { name: 'NY-8086', url: 'wss://community-01.usemapsettings.com:8086/server', password: 'rodshot' },
        { name: 'NY-8087', url: 'wss://community-01.usemapsettings.com:8087/server', password: 'rodshot' },
        { name: 'NY-8088', url: 'wss://community-01.usemapsettings.com:8088/server', password: 'rodshot' },
        { name: 'NY-8089', url: 'wss://community-01.usemapsettings.com:8089/server', password: 'rodshot' }
      ],
      fra: [
        { name: 'FRA-8086', url: 'wss://community-02.usemapsettings.com:8086/server', password: 'rodshot' },
        { name: 'FRA-8087', url: 'wss://community-02.usemapsettings.com:8087/server', password: 'rodshot' },
        { name: 'FRA-8088', url: 'wss://community-02.usemapsettings.com:8088/server', password: 'rodshot' },
        { name: 'FRA-8089', url: 'wss://community-02.usemapsettings.com:8089/server', password: 'rodshot' }
      ]
    };
    
    // ==================== STATE ====================
    let ws = null;
    let selectedServer = null;
    let playerId = null;
    let myName = null;
    
    const state = {
      players: {},
      entityMap: {},
      positions: {},
      ballEntityId: null,
      matchTime: 0,
      recording: false,
      matchData: { startTime: null, samples: [], goals: [] }
    };
    
    let afkInterval = null;
    let recordingInterval = null;
    
    // ==================== VARINT FUNCTIONS ====================
    const w7bit = num => {
      let r = [];
      while (num >= 128) {
        r.push((128 | num) % 256);
        num >>= 7;
      }
      r.push(num % 256);
      return r;
    };
    
    const readVarInt = (arr, start) => {
      let result = 0, shift = 0, pos = start;
      while (pos < arr.length && shift < 35) {
        const byte = arr[pos++];
        result |= (byte & 0x7f) << shift;
        if ((byte & 0x80) === 0) break;
        shift += 7;
      }
      return [result, pos];
    };
    
    const readFloat32 = (arr, start) => {
      if (start + 4 > arr.length) return [0, start + 4];
      const buffer = new Uint8Array(arr.slice(start, start + 4)).buffer;
      return [new Float32Array(buffer)[0], start + 4];
    };
    
    const readString = (arr, start) => {
      const [len, dataStart] = readVarInt(arr, start);
      if (len <= 0 || len > 50 || dataStart + len > arr.length) return ["", start];
      try {
        const str = new TextDecoder().decode(new Uint8Array(arr.slice(dataStart, dataStart + len)));
        return [str, dataStart + len];
      } catch { return ["", start]; }
    };
    
    // ==================== PACKET BUILDERS ====================
    function createAuthPacket(username, uid, password) {
      const usernameBytes = Array.from(username).map(c => c.charCodeAt(0));
      const uidBytes = Array.from(uid).map(c => c.charCodeAt(0));
      const pwdBytes = Array.from(password).map(c => c.charCodeAt(0));
      const teamBytes = w7bit(2); // spectator
      
      const dataBytes = [
        0x0a, usernameBytes.length, ...usernameBytes,
        0x12, uidBytes.length, ...uidBytes,
        0x18, 0xe6, 0x06,
        0x20, ...teamBytes,
        0x2a, pwdBytes.length, ...pwdBytes,
        0x38, 0x01
      ];
      
      const header = [0x08, 0x01, 0x12, dataBytes.length];
      return new Uint8Array([...header, ...dataBytes]);
    }
    
    function createAFKPacket(playerId) {
      const idBytes = w7bit(playerId);
      return new Uint8Array([
        0x08, 0x07, 0x12, 0x0a,
        0x08, 0x01,
        0x12, 0x06,
        0x0d, 0x00, 0x00, 0x00, 0x00,
        0x15, 0x00, 0x00, 0x00, 0x00,
        0x18, ...idBytes
      ]);
    }
    
    function createSpectatorPacket(playerId) {
      const msgBytes = Array.from("/team spectator").map(c => c.charCodeAt(0));
      const idBytes = w7bit(playerId);
      
      const innerPacket = [
        0x08, 0x05, 0x12, 0x0c,
        0x08, ...idBytes,
        0x12, msgBytes.length, ...msgBytes
      ];
      
      const lenBytes = w7bit(innerPacket.length);
      return new Uint8Array([0x0a, ...lenBytes, ...innerPacket]);
    }

    function autoSpectatorWhenReady() {
  const check = setInterval(() => {
    if (ws && ws.readyState === WebSocket.OPEN && playerId) {
      ws.send(createSpectatorPacket(playerId));
      console.log('[SPECTATOR] Auto spectator sent for player', playerId);
      clearInterval(check);
    }
  }, 500);
}
    // ==================== PACKET PARSING ====================
    function parseMessage(data) {
      if (data.length < 5 || data[0] !== 10) return;
      
      const [, afterLen] = readVarInt(data, 1);
      if (data[afterLen] !== 8) return;
      
      const [code] = readVarInt(data, afterLen + 1);
      
      switch (code) {
        case 2: case 3: case 8: case 13: case 15:
          parsePlayerList(data);
          parseEntityMappings(data);
          break;
        case 6:
          parsePositions(data);
          break;
        case 11:
          parseGoal(data);
          break;
        case 12:
          parseGameState(data);
          break;
      }
      
      updateLiveView();
    }
    
    function parsePlayerList(arr) {
      let currentId = null, currentName = null, currentTeam = 0;
      
      for (let i = 0; i < arr.length - 2; i++) {
        if (arr[i] === 8) {
          const [val, nextPos] = readVarInt(arr, i + 1);
          if (val >= 100 && val < 15000) {
            // Check if this is a player (has name nearby)
            for (let j = nextPos; j < Math.min(nextPos + 5, arr.length); j++) {
              if (arr[j] === 18) {
                const [strLen] = readVarInt(arr, j + 1);
                if (strLen >= 2 && strLen <= 20) {
                  if (currentId !== null && currentName !== null) {
                    state.players[currentId] = { name: currentName, team: currentTeam };
                  }
                  currentId = val;
                  currentName = null;
                  currentTeam = 0;
                  break;
                }
              }
            }
          }
        }
        
        if (arr[i] === 18 && currentId !== null && currentName === null) {
          const [str] = readString(arr, i + 1);
          if (str.length >= 2 && str.length <= 20 && !/^[a-f0-9]{8}-/i.test(str)) {
            currentName = str;
            // Check if this is us
            if (!myName) {
              myName = str;
              playerId = currentId;
              document.getElementById('myId').textContent = playerId;
            }
          }
        }
        
        if (arr[i] === 40 && currentId !== null) {
          const [val] = readVarInt(arr, i + 1);
          if (val === 1) currentTeam = 1;
        }
      }
      
      if (currentId !== null && currentName !== null) {
        state.players[currentId] = { name: currentName, team: currentTeam };
      }
    }
    
    function parseEntityMappings(arr) {
      const knownIds = new Set(Object.keys(state.players).map(Number));
      
      for (let i = 0; i < arr.length - 10; i++) {
        if (arr[i] === 10) {
          const [blockLen, afterBlock] = readVarInt(arr, i + 1);
          if (blockLen >= 20 && blockLen <= 100 && arr[afterBlock] === 8) {
            const [entityId, afterEntity] = readVarInt(arr, afterBlock + 1);
            if (entityId > 1000 && entityId < 10000000 && !state.entityMap[entityId]) {
              const blockEnd = Math.min(i + blockLen + 5, arr.length - 2);
              for (let j = afterEntity; j < blockEnd; j++) {
                if (arr[j] === 24) {
                  const [constId] = readVarInt(arr, j + 1);
                  if (knownIds.has(constId)) {
                    state.entityMap[entityId] = constId;
                    break;
                  }
                }
              }
            }
          }
        }
      }
    }
    
    function parsePositions(arr) {
      const now = Date.now();
      for (let i = 0; i < arr.length - 15; i++) {
        if (arr[i] === 18 && arr[i + 2] === 8) {
          const sublen = arr[i + 1];
          if (sublen >= 10 && sublen <= 50) {
            const [entityId, nextPos] = readVarInt(arr, i + 3);
            
            if (entityId > 100 && entityId < 1000000) {
              for (let j = nextPos; j < Math.min(nextPos + 20, arr.length - 10); j++) {
                if (arr[j] === 18 && arr[j + 1] === 10 && arr[j + 2] === 13) {
                  const [x] = readFloat32(arr, j + 3);
                  if (arr[j + 7] === 21) {
                    const [z] = readFloat32(arr, j + 8);
                    
                    if (Math.abs(x) < 500 && Math.abs(z) < 500) {
                      const prev = state.positions[entityId];
                      state.positions[entityId] = {
                        x, z,
                        prevX: prev?.x ?? x,
                        prevZ: prev?.z ?? z,
                        lastUpdate: now
                      };
                      
                      if (!state.entityMap[entityId]) {
                        if (state.ballEntityId === null || entityId > state.ballEntityId) {
                          state.ballEntityId = entityId;
                        }
                      }
                    }
                  }
                  break;
                }
              }
            }
          }
        }
      }
    }
    
    function parseGameState(arr) {
      for (let i = 0; i < arr.length - 4; i++) {
        if (arr[i] === 13) {
          const [time] = readFloat32(arr, i + 1);
          if (time >= 0 && time <= 600) {
            state.matchTime = time;
            const mins = Math.floor(time / 60);
            const secs = Math.floor(time % 60);
            document.getElementById('matchTime').textContent = `${mins}:${secs.toString().padStart(2,'0')}`;
          }
          break;
        }
      }
    }
    
    function parseGoal(arr) {
      const now = Date.now();
      let scorer = null, team = null;
      
      for (let i = 0; i < arr.length - 3; i++) {
        if (arr[i] === 8) {
          const [val] = readVarInt(arr, i + 1);
          if (val >= 100 && val < 15000) {
            const player = state.players[val];
            if (player) {
              scorer = player.name;
              team = player.team === 1 ? 'blue' : 'red';
              break;
            }
          }
        }
      }
      
      if (state.recording && state.matchData.startTime) {
        state.matchData.goals.push({
          t: now - state.matchData.startTime,
          matchTime: state.matchTime,
          scorer,
          team
        });
      }
      
      // Show goal alert
      showGoalAlert({ scorer, team });
    }
    
    // ==================== LIVE VIEW RENDERING ====================
    function updateLiveView() {
      document.getElementById('playerCount').textContent = Object.keys(state.players).length;
      
      // Update player list
      const playerList = document.getElementById('playerList');
      let html = '';
      
      Object.entries(state.players).forEach(([id, p]) => {
        let pos = null;
        for (const [eId, data] of Object.entries(state.positions)) {
          if (state.entityMap[eId] == id) {
            pos = data;
            break;
          }
        }
        
        html += `
          <div class="player-item">
            <div class="player-dot ${p.team === 1 ? 'blue' : 'red'}"></div>
            <span class="player-name">${p.name}${id == playerId ? ' (you)' : ''}</span>
            <span class="player-position">${pos ? `${pos.x.toFixed(1)}, ${pos.z.toFixed(1)}` : ''}</span>
          </div>
        `;
      });
      
      playerList.innerHTML = html || '<div style="color:#555;">No players yet</div>';
      
      // Update detailed player list
      const detailedList = document.getElementById('detailedPlayerList');
      let detailedHtml = '<div style="margin-bottom:10px;"><strong>Blue Team</strong></div>';
      
      Object.entries(state.players).filter(([_, p]) => p.team === 1).forEach(([id, p]) => {
        detailedHtml += `<div style="color:#00d4ff; padding:2px 0;">${p.name}</div>`;
      });
      
      detailedHtml += '<div style="margin:10px 0 5px;"><strong>Red Team</strong></div>';
      Object.entries(state.players).filter(([_, p]) => p.team === 0).forEach(([id, p]) => {
        detailedHtml += `<div style="color:#ff4466; padding:2px 0;">${p.name}</div>`;
      });
      
      detailedList.innerHTML = detailedHtml;
      

    }
    
    function renderCanvas() {
      const canvas = document.getElementById('liveCanvas');
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;
      
      ctx.clearRect(0, 0, w, h);
      
      // Draw field
      ctx.fillStyle = '#1e4d2b';
      ctx.fillRect(0, 0, w, h);
      
      // Center line
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, h/2);
      ctx.lineTo(w, h/2);
      ctx.stroke();
      
      // Center circle
      ctx.beginPath();
      ctx.arc(w/2, h/2, 40, 0, Math.PI*2);
      ctx.stroke();
      
      // Goals
      ctx.strokeStyle = '#00d4ff';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(w*0.35, h-1);
      ctx.lineTo(w*0.65, h-1);
      ctx.stroke();
      
      ctx.strokeStyle = '#ff4466';
      ctx.beginPath();
      ctx.moveTo(w*0.35, 1);
      ctx.lineTo(w*0.65, 1);
      ctx.stroke();
      
      // Scale
      const scaleX = x => ((x - FIELD.minX) / (FIELD.maxX - FIELD.minX)) * w;
      const scaleZ = z => h - ((z - FIELD.minZ) / (FIELD.maxZ - FIELD.minZ)) * h;
      
      // Draw ball
      if (state.ballEntityId && state.positions[state.ballEntityId]) {
        const ball = state.positions[state.ballEntityId];
        const bx = scaleX(ball.x);
        const bz = scaleZ(ball.z);
        
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(bx, bz, 6, 0, Math.PI*2);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.shadowBlur = 0;
      }
      
      // Draw players
      Object.entries(state.positions).forEach(([entityId, pos]) => {
        const constId = state.entityMap[entityId];
        if (!constId || constId === state.ballEntityId) return;
        
        const player = state.players[constId];
        if (!player) return;
        
        const px = scaleX(pos.x);
        const pz = scaleZ(pos.z);
        const color = player.team === 1 ? '#00d4ff' : '#ff4466';
        
        ctx.shadowColor = color;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(px, pz, 8, 0, Math.PI*2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Name
        ctx.font = 'bold 8px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#000';
        ctx.shadowBlur = 3;
        ctx.fillText(player.name.slice(0, 6), px, pz - 15);
        ctx.shadowBlur = 0;
      });
      
      requestAnimationFrame(renderCanvas);
    }
    
    function showGoalAlert(goal) {
      const alert = document.createElement('div');
      alert.style.cssText = `
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: rgba(0,0,0,0.9); padding: 30px 60px; border-radius: 12px;
        text-align: center; z-index: 1000; border: 2px solid ${goal.team === 'blue' ? '#00d4ff' : '#ff4466'};
        color: ${goal.team === 'blue' ? '#00d4ff' : '#ff4466'}; font-size: 48px; font-weight: bold;
      `;
      alert.innerHTML = `GOAL!<br><span style="font-size:24px;">${goal.scorer || 'Someone'}</span>`;
      document.body.appendChild(alert);
      setTimeout(() => alert.remove(), 2000);
    }
    
    // ==================== CONNECTION ====================
    function connectToServer(server) {
  if (ws) ws.close();
  
  playerId = null;
  myName = null;
  state.players = {};
  state.entityMap = {};
  state.positions = {};
  state.ballEntityId = null;
  
  updateStatus('connecting', 'Connecting...');
  
  try {
    ws = new WebSocket(server.url);
    ws.binaryType = 'arraybuffer';
    
    // ---- OPEN ----
    ws.onopen = () => {
      updateStatus('connected', `Connected to ${server.name}`);
      
      const username = `Duck_${Math.floor(Math.random() * 1000)}`;
      const uid = Array(28).fill().map(() => 
        'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'[Math.floor(Math.random() * 62)]
      ).join('');
      
      const authPacket = createAuthPacket(
        username,
        uid,
        document.getElementById('passwordInput').value || 'rodshot'
      );
      
      ws.send(authPacket);
      autoSpectatorWhenReady();

      // Safe heartbeat (prevents disconnect without movement spam)
      if (afkInterval) clearInterval(afkInterval);
      afkInterval = setInterval(() => {
        if (ws && ws.readyState === WebSocket.OPEN && playerId) {
          ws.send(createAFKPacket(playerId));
        }
      }, 10000);
    };
    
    // ---- MESSAGE ----
    ws.onmessage = (event) => {
      const data = new Uint8Array(event.data);
      parseMessage(data);
    };
    
    // ---- CLOSE ----
    ws.onclose = () => {
      updateStatus('disconnected', 'Disconnected');
      if (afkInterval) {
        clearInterval(afkInterval);
        afkInterval = null;
      }
    };
    
    // ---- ERROR ----
    ws.onerror = () => {
      updateStatus('disconnected', 'Connection error');
    };
    
  } catch (e) {
    updateStatus('disconnected', 'Connection failed');
  }
}
    
    // ==================== RECORDING ====================
    function startRecording() {
      state.recording = true;
      state.matchData = { startTime: Date.now(), samples: [], goals: [] };
      recordingInterval = setInterval(captureSample, 200);
      document.getElementById('startRecordBtn').textContent = '‚èπ Stop';
    }
    
    function stopRecording() {
      state.recording = false;
      if (recordingInterval) {
        clearInterval(recordingInterval);
        recordingInterval = null;
      }
      saveMatch();
      document.getElementById('startRecordBtn').textContent = '‚è∫ Record';
    }
    
    function captureSample() {
      if (!state.recording) return;
      
      const now = Date.now();
      const t = now - state.matchData.startTime;
      
      const ball = state.ballEntityId && state.positions[state.ballEntityId] ? {
        x: state.positions[state.ballEntityId].x,
        z: state.positions[state.ballEntityId].z
      } : null;
      
      const players = [];
      Object.entries(state.positions).forEach(([entityId, pos]) => {
        const constId = state.entityMap[entityId];
        if (!constId || constId === state.ballEntityId) return;
        
        const player = state.players[constId];
        if (!player) return;
        
        players.push({
          name: player.name,
          team: player.team === 1 ? 'blue' : 'red',
          x: pos.x,
          z: pos.z
        });
      });
      
      state.matchData.samples.push({ t, ball, players });
    }
    
    function saveMatch() {
      const exportData = {
        recorded: new Date(state.matchData.startTime).toISOString(),
        duration: Date.now() - state.matchData.startTime,
        players: state.players,
        goals: state.matchData.goals,
        samples: state.matchData.samples
      };
      
      const saved = JSON.parse(localStorage.getItem('duck-saved-games') || '[]');
      saved.push({
        id: Date.now(),
        name: `Match ${new Date().toLocaleString()}`,
        data: exportData
      });
      localStorage.setItem('duck-saved-games', JSON.stringify(saved));
      
      updateSavedGames();
    }
    
    function updateSavedGames() {
      const saved = JSON.parse(localStorage.getItem('duck-saved-games') || '[]');
      const container = document.getElementById('savedGamesList');
      
      if (saved.length === 0) {
        container.innerHTML = '<div style="color:#555;">No saved games</div>';
        return;
      }
      
      container.innerHTML = saved.reverse().map(game => {
        const blueGoals = game.data.goals?.filter(g => g.team === 'blue').length || 0;
        const redGoals = game.data.goals?.filter(g => g.team === 'red').length || 0;
        
        return `
          <div class="game-card" onclick="viewGame('${game.id}')">
            <div class="game-date">${new Date(game.data.recorded).toLocaleString()}</div>
            <div class="game-score">
              <span style="color:#00d4ff;">${blueGoals}</span>
              <span>-</span>
              <span style="color:#ff4466;">${redGoals}</span>
            </div>
            <div style="color:#888;">${Object.keys(game.data.players).length} players</div>
          </div>
        `;
      }).join('');
    }
    
    window.viewGame = function(id) {
      const saved = JSON.parse(localStorage.getItem('duck-saved-games') || '[]');
      const game = saved.find(g => g.id == id);
      if (game) {
        const win = window.open('');
        win.document.write(createReplayHTML(game.data));
      }
    };
    
    function createReplayHTML(data) {
      return `
        <!DOCTYPE html>
        <html>
        <head>
          <title>Match Replay</title>
          <style>
            body { background: #0d0d1a; color: #fff; font-family: Arial; margin:0; padding:20px; }
            canvas { display:block; margin:0 auto; border:2px solid #00d4ff; border-radius:8px; }
            .controls { text-align:center; margin-top:20px; }
            button { background:#00d4ff; border:none; padding:10px 20px; margin:0 5px; cursor:pointer; }
          </style>
        </head>
        <body>
          <canvas id="replayCanvas" width="450" height="650"></canvas>
          <div class="controls">
            <button onclick="play()">‚ñ∂ Play</button>
            <button onclick="pause()">‚è∏ Pause</button>
            <span id="time">0:00</span>
          </div>
          <script>
            const gameData = ${JSON.stringify(data)};
            const canvas = document.getElementById('replayCanvas');
            const ctx = canvas.getContext('2d');
            const FIELD = { minX: -15, maxX: 30, minZ: -25, maxZ: 40 };
            
            let frame = 0, playing = false;
            
            function draw() {
              const sample = gameData.samples[frame] || gameData.samples[0];
              if (!sample) return;
              
              ctx.clearRect(0,0,450,650);
              ctx.fillStyle = '#1e4d2b';
              ctx.fillRect(0,0,450,650);
              
              const scaleX = x => ((x - FIELD.minX) / (FIELD.maxX - FIELD.minX)) * 450;
              const scaleZ = z => 650 - ((z - FIELD.minZ) / (FIELD.maxZ - FIELD.minZ)) * 650;
              
              if (sample.ball) {
                const x = scaleX(sample.ball.x);
                const z = scaleZ(sample.ball.z);
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(x, z, 5, 0, Math.PI*2);
                ctx.fill();
              }
              
              sample.players?.forEach(p => {
                const x = scaleX(p.x);
                const z = scaleZ(p.z);
                ctx.fillStyle = p.team === 'blue' ? '#00d4ff' : '#ff4466';
                ctx.beginPath();
                ctx.arc(x, z, 8, 0, Math.PI*2);
                ctx.fill();
              });
              
              const secs = Math.floor(sample.t / 1000);
              document.getElementById('time').textContent = \`\${Math.floor(secs/60)}:\${(secs%60).toString().padStart(2,'0')}\`;
            }
            
            function play() {
              playing = true;
              function step() {
                if (!playing) return;
                frame = Math.min(frame + 1, gameData.samples.length - 1);
                draw();
                setTimeout(step, 200);
              }
              step();
            }
            
            function pause() { playing = false; }
            
            draw();
          <\/script>
        </body>
        </html>
      `;
    }
    
    // ==================== UI HELPERS ====================
    function updateStatus(status, text) {
      const dot = document.getElementById('statusDot');
      const statusText = document.getElementById('statusText');
      
      dot.className = `status-dot ${status}`;
      statusText.textContent = text;
      
      document.getElementById('connectionStatus').className = `status-dot ${status}`;
      document.getElementById('connectBtn').disabled = !selectedServer;
      document.getElementById('disconnectBtn').disabled = status !== 'connected';
    }
    
    // ==================== INIT ====================
    function init() {
      // Render server lists
      const nyDiv = document.getElementById('ny-servers');
      SERVERS.ny.forEach(s => {
        const div = document.createElement('div');
        div.className = 'server-card';
        div.innerHTML = `<span class="name">${s.name}</span><span class="status"></span>`;
        div.onclick = () => {
          document.querySelectorAll('.server-card').forEach(c => c.classList.remove('selected'));
          div.classList.add('selected');
          selectedServer = s;
          document.getElementById('connectBtn').disabled = false;
        };
        nyDiv.appendChild(div);
      });
      
      const fraDiv = document.getElementById('fra-servers');
      SERVERS.fra.forEach(s => {
        const div = document.createElement('div');
        div.className = 'server-card';
        div.innerHTML = `<span class="name">${s.name}</span><span class="status"></span>`;
        div.onclick = () => {
          document.querySelectorAll('.server-card').forEach(c => c.classList.remove('selected'));
          div.classList.add('selected');
          selectedServer = s;
          document.getElementById('connectBtn').disabled = false;
        };
        fraDiv.appendChild(div);
      });
      
      // Connect button
      document.getElementById('connectBtn').onclick = () => {
        if (selectedServer) connectToServer(selectedServer);
      };
      
      document.getElementById('disconnectBtn').onclick = disconnect;
      
      // Manual spectator
      document.getElementById('manualSpectatorBtn').onclick = () => {
        if (ws && ws.readyState === WebSocket.OPEN && playerId) {
          ws.send(createSpectatorPacket(playerId));
        }
      };
      
      // Record button
      document.getElementById('startRecordBtn').onclick = () => {
        if (state.recording) stopRecording();
        else startRecording();
      };
      
      // Tab switching
      document.querySelectorAll('.tab').forEach(tab => {
        tab.onclick = () => {
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          
          document.querySelectorAll('.tab-pane').forEach(p => p.classList.add('hidden'));
          document.getElementById(tab.dataset.tab + 'Tab').classList.remove('hidden');
        };
      });
      
      // Saved games
      document.getElementById('showSavedBtn').onclick = () => {
        document.querySelector('[data-tab="saved"]').click();
        updateSavedGames();
      };
      
      document.getElementById('clearSavedBtn').onclick = () => {
        if (confirm('Clear all saved games?')) {
          localStorage.removeItem('duck-saved-games');
          updateSavedGames();
        }
      };
      
      updateSavedGames();
      updateStatus('disconnected', 'Not connected');
      renderCanvas();
    }
    
    init();
  </script>
</body>
</html>
